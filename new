def train_simplified_pinn(model, domain_bounds, epochs=150, lr=1e-3, points_per_batch=1000, 
                          lambda_pde=1.0, lambda_ic=0.1, lambda_bc=0.1):
    """
    Train the simplified PINN model with improvements to maintain high temperatures
    """
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = model.to(device)
    
    # Generate training points
    print("Generating training points...")
    points = generate_grid_points(domain_bounds, nx=30, ny=30, nz=10, nt=15, stage=model.stage)
    num_points = points.shape[0]
    print(f"Generated {num_points} points")
    
    # Generate boundary points
    boundary_points = {}
    
    # Bottom (z=z_min)
    mask = np.abs(points[:, 2] - domain_bounds['z_min']) < 1e-6
    boundary_points['bottom'] = points[mask]
    
    # Top (z=z_max)
    mask = np.abs(points[:, 2] - domain_bounds['z_max']) < 1e-6
    boundary_points['top'] = points[mask]
    
    # Initial condition (t=t_min)
    mask = np.abs(points[:, 3] - domain_bounds['t_min']) < 1e-6
    boundary_points['initial'] = points[mask]
    
    # Generate high-temperature laser path points
    laser_path_points = []
    laser_velocity = model.laser_params['velocity'] / 1000.0  # m/s
    start_x, start_y = model.laser_params['start_pos']
    end_x, end_y = model.laser_params['end_pos']
    path_length = ((end_x - start_x)**2 + (end_y - start_y)**2)**0.5
    travel_time = path_length / laser_velocity
    
    # Create points along laser path at various timesteps
    for t_val in np.linspace(0.1, min(2.0, travel_time), 20):
        fraction = t_val / travel_time
        x_val = start_x + fraction * (end_x - start_x)
        y_val = start_y + fraction * (end_y - start_y)
        z_val = 0.0  # Laser on surface
        
        # Add points around the current laser position
        for dx in [-0.002, -0.001, 0, 0.001, 0.002]:
            for dy in [-0.002, -0.001, 0, 0.001, 0.002]:
                laser_path_points.append([x_val + dx, y_val + dy, z_val, t_val])
    
    laser_path_points = torch.tensor(laser_path_points, dtype=torch.float32)
    print(f"Generated {len(laser_path_points)} laser path points for high-temperature constraint")
    
    # Create optimizer with learning rate scheduler
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=0.8, patience=5, verbose=True)
    
    # Training loop
    print(f"Starting training for {epochs} epochs...")
    for epoch in range(epochs):
        model.train()
        
        # Balance between PDE physics and high-temperature constraint based on epoch
        # Early epochs focus more on high temperatures, later on physics
        heat_importance = max(0.0, 1.0 - epoch / 60.0)  # Linearly decrease from 1.0 to 0.0 over 60 epochs
        
        # Shuffle points
        idx = torch.randperm(num_points)
        points = points[idx]
        
        # Process in batches
        total_loss = 0.0
        total_pde_loss = 0.0
        total_ic_loss = 0.0
        total_bc_loss = 0.0
        total_heat_loss = 0.0
        num_batches = num_points // points_per_batch
        
        for i in range(num_batches):
            start_idx = i * points_per_batch
            end_idx = start_idx + points_per_batch
            batch_points = points[start_idx:end_idx].to(device)
            
            optimizer.zero_grad()
            
            # Extract coordinates
            x, y, z, t = batch_points[:, 0:1], batch_points[:, 1:2], batch_points[:, 2:3], batch_points[:, 3:4]
            
            # Compute PDE residual
            pde_residual, T_pred = model.compute_pde_residual(x, y, z, t)
            pde_loss = torch.mean(pde_residual**2)
            
            # Initial condition loss
            ic_points = boundary_points['initial'][:min(1000, len(boundary_points['initial']))].to(device)
            x_ic, y_ic, z_ic, t_ic = ic_points[:, 0:1], ic_points[:, 1:2], ic_points[:, 2:3], ic_points[:, 3:4]
            T_ic = model(x_ic, y_ic, z_ic, t_ic)
            ic_loss = torch.mean((T_ic - model.T_ambient)**2) / (model.T_ambient**2)
            
            # Boundary condition loss - top surface
            bc_points = boundary_points['top'][:min(1000, len(boundary_points['top']))].to(device)
            x_bc, y_bc, z_bc, t_bc = bc_points[:, 0:1], bc_points[:, 1:2], bc_points[:, 2:3], bc_points[:, 3:4]
            bc_residual, _ = model.compute_bc_residual(x_bc, y_bc, z_bc, t_bc, 'top')
            bc_loss = torch.mean(bc_residual**2)
            
            # Heat source constraint - maintain high temperatures along laser path
            # Only apply during first 80 epochs to establish high temperatures
            if epoch < 80:
                # Sample points along the laser path
                heat_idx = torch.randperm(len(laser_path_points))[:100]
                heat_points = laser_path_points[heat_idx].to(device)
                x_heat, y_heat, z_heat, t_heat = heat_points[:, 0:1], heat_points[:, 1:2], heat_points[:, 2:3], heat_points[:, 3:4]
                
                # Get temperatures at these points
                T_heat = model(x_heat, y_heat, z_heat, t_heat)
                
                # Calculate distance to laser center for each point
                laser_x = start_x + (end_x - start_x) * t_heat / travel_time
                laser_y = torch.ones_like(laser_x) * start_y
                dist_squared = (x_heat - laser_x)**2 + (y_heat - laser_y)**2
                
                # Target temperature based on distance (higher for points closer to laser)
                target_temp = model.T_liquidus * torch.exp(-100.0 * dist_squared) + model.T_ambient
                
                # Loss for points below target temperature
                heat_loss = torch.mean(torch.relu(target_temp - T_heat))
                
                # Scale by heat importance
                heat_loss = heat_loss * heat_importance * 5.0  # Extra weight to heat loss
            else:
                heat_loss = torch.tensor(0.0).to(device)
            
            # Total loss - balance between physics and high temperature constraint
            loss = lambda_pde * pde_loss + lambda_ic * ic_loss + lambda_bc * bc_loss + heat_loss
            
            # Backpropagation
            loss.backward()
            
            # Clip gradients to prevent instability
            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)
            
            optimizer.step()
            
            total_loss += loss.item()
            total_pde_loss += pde_loss.item()
            total_ic_loss += ic_loss.item()
            total_bc_loss += bc_loss.item()
            total_heat_loss += heat_loss.item() if isinstance(heat_loss, torch.Tensor) else 0.0
        
        # Update learning rate
        avg_loss = total_loss / num_batches
        scheduler.step(avg_loss)
        
        # Print progress
        if epoch % 10 == 0 or epoch == epochs - 1:
            avg_loss = total_loss / num_batches
            avg_pde_loss = total_pde_loss / num_batches
            avg_ic_loss = total_ic_loss / num_batches
            avg_bc_loss = total_bc_loss / num_batches
            avg_heat_loss = total_heat_loss / num_batches
            
            print(f"Epoch {epoch}, Loss: {avg_loss:.6f}, LR: {optimizer.param_groups[0]['lr']:.6f}")
            print(f"  PDE: {avg_pde_loss:.6f}, IC: {avg_ic_loss:.6f}, BC: {avg_bc_loss:.6f}, Heat: {avg_heat_loss:.6f}")
            
            # Sample temperature prediction
            with torch.no_grad():
                # Temperature at a point away from laser path
                test_point = torch.tensor([[0.02, 0.01, 0.0, 1.0]], dtype=torch.float32).to(device)
                test_temp = model(test_point[:, 0:1], test_point[:, 1:2], test_point[:, 2:3], test_point[:, 3:4])
                print(f"Temperature at x=0.02, y=0.01, z=0.0, t=1.0: {test_temp.item():.2f} K")
                
                # Temperature near laser path
                test_point = torch.tensor([[0.01, 0.01, 0.0, 1.0]], dtype=torch.float32).to(device)
                test_temp = model(test_point[:, 0:1], test_point[:, 1:2], test_point[:, 2:3], test_point[:, 3:4])
                print(f"Temperature near laser path at x=0.01, y=0.01, z=0.0, t=1.0: {test_temp.item():.2f} K")
                
                # Temperature directly at current laser position (t=1.0)
                fraction = min(1.0 / travel_time, 1.0)
                laser_x = start_x + (end_x - start_x) * fraction
                test_point = torch.tensor([[laser_x, start_y, 0.0, 1.0]], dtype=torch.float32).to(device)
                test_temp = model(test_point[:, 0:1], test_point[:, 1:2], test_point[:, 2:3], test_point[:, 3:4])
                print(f"Temperature at laser position (t=1.0): {test_temp.item():.2f} K")
    
    print("Training completed.")
    return model
